### Introduction to `Sequelize`
`Sequelize` is a popular Object-Relational Mapping (ORM) library for Node.js, which allows you to interact with relational databases like PostgreSQL using JavaScript/Node.js. It provides an easy way to manage your database operations and simplifies the interaction with the database, abstracting SQL queries into JavaScript code. Some key features of `Sequelize` are listed below:-

- `Database Support`: `Sequelize` supports various relational databases, including PostgreSQL, MySQL, SQLite, and MSSQL. This flexibility allows you to switch between different database systems easily.

- `Models and Associations`: `Sequelize` enables you to define models that represent database tables and their relationships (associations) with other tables. These models provide a structured way to interact with the database and handle complex data relationships.

- `Data Validation`: `Sequelize` offers built-in validation support for your models, allowing you to define validation rules for each attribute to ensure data integrity and consistency.

- `Migrations`: With `Sequelize`, you can use migrations to manage changes to the database schema over time. Migrations help keep your database schema in sync with your application’s codebase and facilitate database version control.

- `Querying`: `Sequelize` provides a straightforward API for querying the database, including support for complex queries like filtering, ordering, aggregating, and pagination.

- `Hooks`: `Sequelize` allows you to define hooks that get executed before or after certain events, such as before saving a record or after fetching data. This feature is helpful for performing additional actions or validation during these events.

- `Transactions`: `Sequelize` supports transactions, which are crucial for maintaining data consistency and integrity when dealing with multiple related operations that must either all succeed or all fail.

- `Raw SQL Queries`: While `Sequelize` provides a high-level API for interacting with the database, it also allows you to execute raw SQL queries directly when more complex operations are required.

- `Eager Loading`: `Sequelize` supports eager loading, enabling you to fetch related data along with the main query, which can help avoid the N+1 problem and improve query performance.

- `Pluggable Dialects`: The library is built to support multiple SQL dialects, making it adaptable to various relational database systems.

## Install Postgres
To install PostgreSQL on Ubuntu 20.04 (or any other Ubuntu version), follow these steps:

Install PostgreSQL and its required components:

```bash
sudo apt install postgresql postgresql-contrib
```

Start the PostgreSQL service:

```sudo systemctl start postgresql```
 
You can now connect to PostgreSQL using the `psql` command-line tool. Switch to the `postgres` user and then run `psql`:

```bash
 sudo -u postgres psql
```
Create a New User Role: Replace newusername with the desired username for the new role.

```bash
CREATE USER newusername;
```
Set Password (Optional): You can set a password for the new user role. Replace newusername and newpassword with the actual username and password

```bash
ALTER USER <newusername> WITH PASSWORD <newpassword>;
```
Grant Permissions (Optional): You can grant specific permissions to the new user role. For example, to grant the user role the ability to create databases and roles

```bash
ALTER USER newusername CREATEDB;
ALTER USER newusername CREATEROLE;
```



## Sequelize

### Install
- `sequelize`: The Sequelize library itself.
- `sequelize-cli`: The Sequelize Command Line Interface (CLI) for managing database migrations, models, etc.
- `pg`: The PostgreSQL database driver.

```bash
npm install sequelize sequelize-cli pg
```


### Models
After installing Sequelize, you’ll need to set up the Sequelize configuration and models for your project. Run the following command to initialize Sequelize in your project:


##### Configs

```bash
npx sequelize-cli init
```

This will create the necessary directories and files for Sequelize in your project.

`Configure Database`: Open the `config/config.json` file that was generated by Sequelize initialization and configure your database connection settings. You'll need to provide the database name, username, password, host, and dialect (e.g., "postgres" for PostgreSQL).

`Create Models`: Models represent your database tables and are defined using Sequelize. Create a new model using the Sequelize CLI

##### Migrations

Migrations and Database Setup: Sequelize uses migrations to manage changes to the database schema. To create the initial migration and apply it to the database, run

```bash
npx sequelize-cli db:migrate
```

This will create the necessary tables in your database based on your model definitions.

```js
const { Sequelize, DataTypes } = require('sequelize');

// Configure database connection
const sequelize = new Sequelize('database', 'username', 'password', {
  host: 'localhost',
  dialect: 'postgres',
});

// Define User model
const User = sequelize.define('User', {
  username: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
  },
});

// Define Post model
const Post = sequelize.define('Post', {
  title: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  content: {
    type: DataTypes.TEXT,
    allowNull: false,
  },
});

// Set up associations
User.hasMany(Post);
Post.belongsTo(User);

// Sync models with the database
sequelize.sync({ force: true }) // WARNING: This will drop existing tables and recreate them
  .then(() => {
    console.log('Models synchronized with database.');
  })
  .catch((error) => {
    console.error('Error synchronizing models:', error);
  });
```


##### Model Usages
In Sequelize, models serve as JavaScript representations of database tables. They define the structure of the data that will be stored in the database and provide an interface for querying, creating, updating, and deleting records. Let’s explore how to use models in Sequelize:

`Defining a Model`: To define a model, you use the `sequelize.define()` method. Here's an example of defining a User model:

```js
const { Sequelize, DataTypes } = require('sequelize');

const sequelize = new Sequelize('database', 'username', 'password', {
  host: 'localhost',
  dialect: 'postgres',
});

const User = sequelize.define('User', {
  username: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
  },
});
```

`Creating Records`: You can create records using the create() method on the model:

```js
User.create({
  username: 'john_doe',
  email: 'john@example.com',
})
.then((user) => {
  console.log('New user created:', user.toJSON());
})
.catch((error) => {
  console.error('Error creating user:', error);
});
```


`Querying Records`: You can query records using methods like findOne(), findAll(), and custom query methods. For example:

```js
User.findOne({
  where: { username: 'john_doe' }
})
.then((user) => {
  if (user) {
    console.log('Found user:', user.toJSON());
  } else {
    console.log('User not found.');
  }
})
.catch((error) => {
  console.error('Error querying user:', error);
});

```


`Updating Records`: You can update records using the update() method:

```js
User.update({ username: 'new_username' }, {
  where: { id: 1 }
})
.then((result) => {
  console.log('Updated user:', result);
})
.catch((error) => {
  console.error('Error updating user:', error);
});
```


`Deleting Records`: You can delete records using the destroy() method:

```js
User.destroy({
  where: { id: 1 }
})
.then(() => {
  console.log('User deleted.');
})
.catch((error) => {
  console.error('Error deleting user:', error);
});
```



### Data Types
In the above snippet, we have used `DataTypes` & `Sequelize`, `Sequelize`, and `DataTypes` are key components of the `Sequelize` library, which is an Object-Relational Mapping (ORM) tool for Node.js. `Sequelize` simplifies database interactions by allowing you to work with databases using JavaScript objects and methods, rather than writing raw SQL queries. Here’s a brief introduction to both `Sequelize` and `DataTypes`:

- `Sequelize` is a popular ORM library that provides an abstraction layer for working with relational databases, making it easier to manage and manipulate database records through JavaScript code. It supports various relational database systems, including PostgreSQL, MySQL, SQLite, and MSSQL.


- Key features of `Sequelize` include:
  - `Model Definition`: `Sequelize` allows you to define models, which are JavaScript classes that represent tables in your database. Models define the structure of the table, including columns, data types, and associations with other tables.
 - `Migrations`: `Sequelize` provides a way to manage database schema changes over time using migrations. Migrations are scripts that define changes to the database schema, such as adding or modifying tables and columns.
 - `Querying`: `Sequelize` offers a query interface for creating, reading, updating, and deleting records from the database. It supports both simple and complex queries.
 - `Associations`: `Sequelize` allows you to define relationships (associations) between different models, such as one-to-one, one-to-many, and many-to-many relationships.
 - `Hooks`: `Sequelize` provides hooks (similar to event listeners) that allow you to perform actions before or after certain database operations, such as creating or updating records.
 - `Validation`: You can define validation rules for model attributes to ensure that data meets specific requirements before being stored in the database.

- `DataTypes` is an object provided by `Sequelize` that represents the different data types you can use when defining model attributes. It maps JavaScript data types to the corresponding data types in your database.


- Common `DataTypes` include:
  - `STRING`: Represents variable-length character strings.
  - `INTEGER`: Represents whole numbers.
  - `BOOLEAN`: Represents true or false values.
  - `DATE`: Represents date and time values.
  - `FLOAT, DOUBLE`: Represent floating-point numbers.
  - `TEXT`: Represents large blocks of text.
  - `ENUM`: Represents a fixed set of values.

- When defining a model, you use `DataTypes` to specify the type of each attribute in the model. Here’s a basic example of using `Sequelize` and DataTypes to define a User model with a username and an email attribute:

```js
const { Sequelize, DataTypes } = require('sequelize');

const sequelize = new Sequelize('database', 'username', 'password', {
  host: 'localhost',
  dialect: 'postgres',
});

const User = sequelize.define('User', {
  username: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
  },
});
```

In this example, we’re defining a User model with two attributes: username of type STRING and email of type STRING, both of which are required (allowNull: false).

Sequelize’s DataTypes and model definition make it easy to work with databases using JavaScript, abstracting away the complexities of raw SQL queries.


### Using Associations
In the context of the above example we have used the models in the following snippet

```js
(async () => {
  try {
    // Create a user with associated posts
    const user = await User.create({
      username: 'john_doe',
      email: 'john@example.com',
      Posts: [
        {
          title: 'First Post',
          content: 'This is the content of the first post.',
        },
        {
          title: 'Second Post',
          content: 'This is the content of the second post.',
        },
      ],
    }, {
      include: Post,
    });

    // Find a user and retrieve their posts
    const foundUser = await User.findOne({
      where: { username: 'john_doe' },
      include: Post,
    });

    console.log('User with associated posts:', foundUser.toJSON());

    // Find a post and retrieve its user
    const foundPost = await Post.findOne({
      where: { title: 'First Post' },
      include: User,
    });

    console.log('Post with associated user:', foundPost.toJSON());
  } catch (error) {
    console.error('Error:', error);
  } finally {
    await sequelize.close();
  }
})();
```


### Raw Queries

Raw queries refer to the use of direct SQL statements in your code to interact with a database, bypassing the abstractions provided by Object-Relational Mapping (ORM) libraries like Sequelize. 

While using an ORM like Sequelize is often preferred for its ease of use, raw queries can be useful in certain situations where complex queries or optimizations are required.Here’s an overview of raw queries, including when and how to use them:

##### When to Use Raw Queries: 

You might consider using raw queries in the following scenarios:
- `Performance Optimization`: In cases where a specific query optimization is needed, raw queries can be used to fine-tune database performance.
- `Advanced Queries`: For complex queries that are difficult to express using an ORM’s query builder methods.
- `Stored Procedures`: When you need to call database-stored procedures directly.
- `Database-Specific Features`: For utilizing database-specific features that are not supported by the ORM.


##### Using Raw Queries with Sequelize

Sequelize allows you to execute raw SQL queries using the` sequelize.query()` method. Here's how you can use it:

```js
const { Sequelize } = require('sequelize');

const sequelize = new Sequelize('database', 'username', 'password', {
  host: 'localhost',
  dialect: 'postgres',
});

async function runRawQuery() {
  try {
    const results = await sequelize.query('SELECT * FROM users WHERE age > :age', {
      replacements: { age: 25 }, // Bind parameters
      type: Sequelize.QueryTypes.SELECT,
    });

    console.log('Raw Query Results:', results);
  } catch (error) {
    console.error('Error executing raw query:', error);
  } finally {
    await sequelize.close();
  }
}

runRawQuery();
```


In the example above, we’re using sequelize.query() to execute a raw SQL query that retrieves users older than a specified age. The replacements option is used to bind parameters, enhancing security by preventing SQL injection.

- `Preventing SQL Injection`:When using raw queries, it’s important to properly sanitize and validate user inputs to prevent SQL injection attacks. Sequelize’s parameter binding, as demonstrated in the example above, helps mitigate this risk.
- `Cautions and Considerations`: Raw queries can make your code less portable across different database systems. They can bypass some of the built-in validations and features of the ORM. Use raw queries judiciously and consider whether an ORM’s query builder can fulfill your requirements.
- `Escaping Identifiers`: If you need to use raw identifiers (table/column names) in your SQL queries, you can use the sequelize.literal() function to safely escape them:

```js
sequelize.query(`SELECT * FROM ${sequelize.literal('Users')} WHERE age > :age`, {
  replacements: { age: 25 },
  type: Sequelize.QueryTypes.SELECT,
});
```


## Indexing
Indexing is a database optimization technique that improves the speed of data retrieval operations (such as searching, sorting, and filtering) by creating a data structure that allows for more efficient access to the data. In relational databases like PostgreSQL, indexing plays a crucial role in improving query performance.

In the context of Sequelize and PostgreSQL, you can create indexes on specific columns of your tables to speed up queries involving those columns. Here’s how you can work with indexing in Sequelize:

Creating Indexes: In Sequelize, you can define indexes when defining your model using the indexes option. Indexes can be created on single or multiple columns. Here's an example of creating an index on the email column of the User model:

```js
const { Sequelize, DataTypes } = require('sequelize');

const sequelize = new Sequelize('database', 'username', 'password', {
  host: 'localhost',
  dialect: 'postgres',
});

const User = sequelize.define('User', {
  username: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
  },
}, {
  indexes: [
    {
      unique: true,
      fields: ['email'], // Index on the 'email' column
    }
  ]
});
```

In this example, we’re creating a unique index on the email column. Unique indexes ensure that no two rows have the same value in the indexed column.

`Using Existing Indexes`: If you have existing indexes in your database, Sequelize can use them for query optimization. Sequelize will automatically use the indexes when executing queries that involve indexed columns.

`Custom Index Names`: By default, Sequelize generates index names based on the table name and indexed columns. You can specify custom index names using the name property in the indexes array:

```js
indexes: [
  {
    unique: true,
    fields: ['email'],
    name: 'custom_email_index_name'
  }
]
```

`Removing Indexes`: To remove an index, you can use the sequelize.drop method with the options parameter:

```js
User.drop({
  indexes: [
    'custom_email_index_name', // Name of the index to drop
  ]
});
```

Keep in mind that dropping indexes will result in a change to your database schema, so use caution.

Indexes can significantly improve query performance, especially on large datasets. 

However, over-indexing (creating too many unnecessary indexes) can lead to performance issues during data updates and inserts. Therefore, it’s essential to carefully consider which columns should be indexed based on the types of queries your application performs most frequently.

Always monitor query performance and database usage when using indexes, and be prepared to adjust your indexing strategy as needed.



## Widely used Sequelize Function
`sequelize.define`: Defines a new model with attributes and options.
`sequelize.sync()`: Synchronize model definitions with the database.
`belongsTo`: Creates an association between two models, where one model belongs to another.
`hasMany`: Defines a one-to-many relationship between models.
`belongsToMany`: Creates a many-to-many association between models.
`Model.create`: Creates a new instance of a model and inserts it into the database.
`Model.findAll`: Retrieves all instances of a model from the database.
`Model.findByPk`: Finds a single instance by its primary key.
`Model.update`: Updates instances that match the given conditions.
`Model.destroy`: Deletes instances that match the given conditions.
`Model.findOne`: Finds the first instance that matches the given conditions.
`Model.findAll`: Retrieves instances based on specific conditions.
`Model.count`: Counts the number of instances that match the given conditions.
`Model.bulkCreate()`: Bulk insert multiple records.
`Model.findAll({ order, limit, offset })`: Allows sorting and pagination of query results.
`sequelize.fn`: Provides access to various SQL functions (e.g., SUM, COUNT, AVG, etc.).
`sequelize.col`: Represents a column in the database.
`sequelize.query`: Executes raw SQL queries and returns the results.


There are numerous functions available for individuals to use according to their requirements. If you wish to learn more about how to use sequelize with Postgres, you can refer to the official documentation of Postgres and sequelize for detailed information.